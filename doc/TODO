# $Id: TODO,v 1.6 2002/08/13 06:29:21 jpwarren Exp $
# $Revision: 1.6 $
#
#    BEEPy - A Python BEEP Library
#    Copyright (C) 2002 Justin Warren <daedalus@eigenmagic.com>
#
#    This library is free software; you can redistribute it and/or
#    modify it under the terms of the GNU Lesser General Public
#    License as published by the Free Software Foundation; either
#    version 2.1 of the License, or (at your option) any later version.
#
#    This library is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
#    Lesser General Public License for more details.
#
#    You should have received a copy of the GNU Lesser General Public
#    License along with this library; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
# This file tracks items that are outstanding as a sort of scratch monkey
# used during coding sessions so I can keep track of things that occur to
# me while doing something else. It's easier to import into CVS than
# yellow sticky notes. :)

- Channel.pull() returns a message instead of a frame. why?
- Channel.allocateRemoteSeqno() and similar: check for need for mutex
  because of concurrency and synchronisation issues.
- Possible rationalisation of Exceptions classes in some cases. I'm having
  to draw lots of Exception classes in Dia to document this thing. I wonder
  if string comparison is quicker than class instanciation during exception
  processing?
- architecture.dia: SEQFrame.type == 'SEQ'. Is this in beep.core.constants
  somewhere, and why?
- beep.core.message should probably be moved to beep.core.profiles since
  message is an enabling class for the BEEPMgmtProfile class. mgmtcreator
  and mgmtparser can probably be moved too, since the mgmt thingo is
  structured in as a profile, not core anymore.
- How does the library search for user defined profiles?
- If we define the URI for a profile when we add it to a ProfileDict, 
  why does the Profile have a uri attribute?
- Where does fragmentation get handled? Probably should be in the
  transport code somewhere, so we need to be careful with buffer overflows
  in the rest of the code. May also affect where MIME encoding occurs.
- I think I've finally worked out how the complex profiles should work.
  To fit with my model, you really need to have a supporting transport
  for anything that deals with raw sockets like TLS. What a TLS profile
  would do is deal with the channel side of things to set up a tuning
  reset, which means it would deal directly with the SessionManager to
  migrate the open socket from the current Session to a new TLSSession,
  such as a TLSTCPSession which would inherit from TCPSessionListener
  (for example) and simply overload the TCPCommsMixin class to define
  TLS layer stuff. This would mean the encryption/decryption will happen
  before the Session class even sees the frames, and so once a tuning
  reset occurs, BEEP could get restarted happily. Everything would be
  tunnelled over TLS at raw socket level, but once the data came through
  the TLSCommsMixin functions it would be the same data as you'd get from
  a TCPCommsMixin over an unencrypted connection. Once the socket got
  moved over to the new Session, the current Profile would exit and
  the other session would just kick off as if it'd just been started.
  Easy.
- Add profile priorities for when a client might ask to start a channel
  and give a list of profiles. The server will then pick the one that it
  knows about that has the highest priority. This allows the server to
  prefer SASL/OTP over SASL/ANONYMOUS, for example.
- Need to fix state machine and synchronisations so that on a tuning
  reset the new session doesn't become active until after the old one
  has exitted. Probably need some form of thread synchro via join().
